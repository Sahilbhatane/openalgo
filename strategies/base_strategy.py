"""
Base Strategy Class for OpenAlgo Intraday Trading Bot

This module provides the abstract base class for all trading strategies.
All strategy implementations should inherit from BaseStrategy.

Author: OpenAlgo Team
Date: December 2025
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

import pandas as pd


class SignalAction(Enum):
    """Trading signal actions"""

    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    EXIT = "EXIT"  # Exit existing position
    SCALE_IN = "SCALE_IN"  # Add to position
    SCALE_OUT = "SCALE_OUT"  # Reduce position


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    Attributes:
        action: The trading action (BUY, SELL, HOLD, etc.)
        entry_price: Suggested entry price
        stop_loss: Stop-loss price
        targets: List of target prices (can have multiple targets)
        qty: Suggested quantity
        reason: Human-readable reason for the signal
        confidence: Signal confidence (0.0 to 1.0)
        timestamp: When the signal was generated
        metadata: Additional signal metadata
    """

    action: SignalAction
    entry_price: float = 0.0
    stop_loss: float = 0.0
    targets: List[float] = field(default_factory=list)
    qty: int = 0
    reason: str = ""
    confidence: float = 0.0
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary for JSON serialization"""
        return {
            "action": self.action.value,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "targets": self.targets,
            "qty": self.qty,
            "reason": self.reason,
            "confidence": self.confidence,
            "timestamp": self.timestamp.isoformat(),
            "metadata": self.metadata,
        }

    @classmethod
    def hold(cls, reason: str = "No signal") -> "Signal":
        """Create a HOLD signal"""
        return cls(action=SignalAction.HOLD, reason=reason)

    @classmethod
    def buy(
        cls,
        entry_price: float,
        stop_loss: float,
        targets: List[float],
        qty: int,
        reason: str,
        confidence: float = 0.5,
        **metadata,
    ) -> "Signal":
        """Create a BUY signal"""
        return cls(
            action=SignalAction.BUY,
            entry_price=entry_price,
            stop_loss=stop_loss,
            targets=targets,
            qty=qty,
            reason=reason,
            confidence=confidence,
            metadata=metadata,
        )

    @classmethod
    def sell(
        cls,
        entry_price: float,
        stop_loss: float,
        targets: List[float],
        qty: int,
        reason: str,
        confidence: float = 0.5,
        **metadata,
    ) -> "Signal":
        """Create a SELL signal"""
        return cls(
            action=SignalAction.SELL,
            entry_price=entry_price,
            stop_loss=stop_loss,
            targets=targets,
            qty=qty,
            reason=reason,
            confidence=confidence,
            metadata=metadata,
        )


@dataclass
class StrategyConfig:
    """
    Configuration for a trading strategy.

    Attributes:
        name: Strategy name
        enabled: Whether strategy is active
        mode: Trading mode ('PAPER' or 'LIVE')
        capital: Capital allocated to this strategy
        risk_per_trade: Max risk per trade as decimal
        max_trades_per_day: Maximum trades allowed per day
        max_position_size: Max position as fraction of capital
        allowed_symbols: List of allowed symbols (empty = all)
        trading_start_time: Trading window start (HH:MM)
        trading_end_time: Trading window end (HH:MM)
        exit_before_close_minutes: Minutes before market close to exit
    """

    name: str = "BaseStrategy"
    enabled: bool = True
    mode: str = "PAPER"  # PAPER or LIVE
    capital: float = 100000.0
    risk_per_trade: float = 0.02  # 2%
    max_trades_per_day: int = 10
    max_position_size: float = 0.10  # 10%
    allowed_symbols: List[str] = field(default_factory=list)
    trading_start_time: str = "09:20"  # After opening range
    trading_end_time: str = "15:10"  # Before close
    exit_before_close_minutes: int = 20

    def to_dict(self) -> Dict[str, Any]:
        """Convert config to dictionary"""
        return {
            "name": self.name,
            "enabled": self.enabled,
            "mode": self.mode,
            "capital": self.capital,
            "risk_per_trade": self.risk_per_trade,
            "max_trades_per_day": self.max_trades_per_day,
            "max_position_size": self.max_position_size,
            "allowed_symbols": self.allowed_symbols,
            "trading_start_time": self.trading_start_time,
            "trading_end_time": self.trading_end_time,
            "exit_before_close_minutes": self.exit_before_close_minutes,
        }


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    All strategy implementations must inherit from this class and implement
    the abstract methods.

    Example:
        class MyStrategy(BaseStrategy):
            def generate_signal(self, live_bar, history, indicators, plan_entry):
                # Your strategy logic here
                return Signal.hold("No conditions met")
    """

    def __init__(self, config: Union[Dict[str, Any], StrategyConfig]):
        """
        Initialize the strategy.

        Args:
            config: Strategy configuration (dict or StrategyConfig)
        """
        if isinstance(config, dict):
            self.config = StrategyConfig(**config)
        else:
            self.config = config

        self.name = self.config.name
        self.trades_today = 0
        self.last_signal_time: Optional[datetime] = None
        self.position_open = False
        self.current_position: Dict[str, Any] = {}

        # Statistics
        self.signals_generated = 0
        self.winning_trades = 0
        self.losing_trades = 0

    @abstractmethod
    def generate_signal(
        self,
        live_bar: Dict[str, Any],
        history: pd.DataFrame,
        indicators: Dict[str, Any],
        plan_entry: Optional[Dict[str, Any]] = None,
    ) -> Signal:
        """
        Generate a trading signal based on current market data.

        This is the main method that each strategy must implement.

        Args:
            live_bar: Current bar data with keys:
                - open, high, low, close, volume
                - timestamp
                - symbol
            history: Historical OHLCV DataFrame
            indicators: Pre-computed indicators dict with keys like:
                - atr, rsi, vwap, sma_20, ema_9, etc.
            plan_entry: Optional entry from morning's today_plan.json:
                - entry_zones, stop_loss, targets, suggested_qty

        Returns:
            Signal object with action, prices, qty, and reason
        """
        pass

    def can_trade(self, current_time: datetime) -> bool:
        """
        Check if trading is allowed at the current time.

        Args:
            current_time: Current datetime

        Returns:
            True if trading is allowed
        """
        # Check if strategy is enabled
        if not self.config.enabled:
            return False

        # Check max trades per day
        if self.trades_today >= self.config.max_trades_per_day:
            return False

        # Check trading window
        time_str = current_time.strftime("%H:%M")
        if time_str < self.config.trading_start_time:
            return False
        if time_str > self.config.trading_end_time:
            return False

        return True

    def should_exit(self, current_time: datetime) -> bool:
        """
        Check if position should be exited due to end of day.

        Args:
            current_time: Current datetime

        Returns:
            True if should exit
        """
        # Exit before market close
        time_str = current_time.strftime("%H:%M")
        exit_time = self.config.trading_end_time

        if time_str >= exit_time:
            return True

        return False

    def record_trade(self, signal: Signal, result: str = "pending") -> None:
        """
        Record a trade for statistics.

        Args:
            signal: The signal that was executed
            result: Trade result ('win', 'loss', 'pending')
        """
        self.trades_today += 1
        self.signals_generated += 1
        self.last_signal_time = datetime.now()

        if result == "win":
            self.winning_trades += 1
        elif result == "loss":
            self.losing_trades += 1

    def reset_daily_stats(self) -> None:
        """Reset daily statistics (call at start of each trading day)"""
        self.trades_today = 0
        self.last_signal_time = None

    def get_stats(self) -> Dict[str, Any]:
        """Get strategy statistics"""
        total_trades = self.winning_trades + self.losing_trades
        win_rate = self.winning_trades / total_trades if total_trades > 0 else 0.0

        return {
            "name": self.name,
            "trades_today": self.trades_today,
            "signals_generated": self.signals_generated,
            "winning_trades": self.winning_trades,
            "losing_trades": self.losing_trades,
            "win_rate": round(win_rate * 100, 2),
            "position_open": self.position_open,
        }

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name='{self.name}', enabled={self.config.enabled})"
